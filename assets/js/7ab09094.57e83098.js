"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6513],{6504:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>h,contentTitle:()=>s,default:()=>b,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var n=i(4848),o=i(8453);i(6025);const t={sidebar_position:1},s="INeighborQueryJobWrapper",a={id:"documentation-core/queries/neighbor_queries/neighbor-queries",title:"INeighborQueryJobWrapper",description:"Neighbor queries are implementations of INeighborQueryJobWrapper. Given two sets of entities, they find MaxNumNeighbors neighbors for each entity from the first set. Normally this is MaxNumNeighbors nearest entities restricted by field of view FOV, but generally other criteria of a neighborhood could be implemented. The resulting neighborhood is passed into neighbor behaviors.",source:"@site/docs/4_documentation-core/5_queries/0_neighbor_queries/1_neighbor-queries.mdx",sourceDirName:"4_documentation-core/5_queries/0_neighbor_queries",slug:"/documentation-core/queries/neighbor_queries/neighbor-queries",permalink:"/Steering-AI-Documentation/docs/documentation-core/queries/neighbor_queries/neighbor-queries",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/Steering-AI-Documentation/docs/documentation-core/queries/neighbor_queries/overview"},next:{title:"NeighborQueryParams",permalink:"/Steering-AI-Documentation/docs/documentation-core/queries/neighbor_queries/neighbor-params"}},h={},c=[{value:"Implementing a Neighbor Query",id:"implementing-a-neighbor-query",level:2},{value:"Neighbors Array Format",id:"neighbors-array-format",level:3}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"ineighborqueryjobwrapper",children:"INeighborQueryJobWrapper"})}),"\n",(0,n.jsxs)(r.p,{children:["Neighbor queries are implementations of ",(0,n.jsx)(r.code,{children:"INeighborQueryJobWrapper"}),". Given two sets of entities, they find ",(0,n.jsx)(r.code,{children:"MaxNumNeighbors"})," neighbors for each entity from the first set. Normally this is ",(0,n.jsx)(r.code,{children:"MaxNumNeighbors"})," nearest entities restricted by field of view ",(0,n.jsx)(r.code,{children:"FOV"}),", but generally other criteria of a neighborhood could be implemented. The resulting neighborhood is passed into ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/behaviors/neighbor-behaviors/intro",children:"neighbor behaviors"}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"implementing-a-neighbor-query",children:"Implementing a Neighbor Query"}),"\n",(0,n.jsxs)(r.p,{children:["To implement your own neighbor query, create a class implementing the ",(0,n.jsx)(r.code,{children:"INeighborQueryJobWrapper"})," interface. Mark it with ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes#jobwrapperattribute",children:(0,n.jsx)(r.code,{children:"[JobWrapper]"})}),", this will make it show up in the ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/editor",children:"editor"}),". The schedule method is expected to schedule a ",(0,n.jsx)(r.a,{href:"https://docs.unity3d.com/Manual/job-system.html",children:"job"})," which finds neighbors and writes them to the ",(0,n.jsx)(r.code,{children:"neighbors"})," array. See below for details about the format of ",(0,n.jsx)(r.code,{children:"neighbors"}),", which the behaviors will expect. All the data necessary to find the neighbors is passed inside ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/queries/neighbor_queries/neighbor-params",children:(0,n.jsx)(r.code,{children:"NeighborQueryParams"})}),"."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",metastring:'title="MyNeighborQueryJobWrapper.cs"',children:"[JobWrapper]\r\npublic class MyNeighborQueryJobWrapper : INeighborQueryJobWrapper\r\n{\r\n    public JobHandle Schedule(\r\n        SystemBase systemBase,\r\n        in NeighborQueryParams neighborQueryParams,\r\n        in NativeArray<NeighborMatch> neighbors,\r\n        in JobHandle dependency)\r\n    {\r\n        var handle = new MyNeighborQueryJob(neighborQueryParams).Schedule(dependency);\r\n        return handle;\r\n    }\r\n}\n"})}),"\n",(0,n.jsx)(r.h3,{id:"neighbors-array-format",children:"Neighbors Array Format"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"neighbors"})," array is passed in preallocated with ",(0,n.jsx)(r.code,{children:"MaxNumNeighbors"})," elements for each entity. The expected format is that indexes ",(0,n.jsx)(r.code,{children:"i * MaxNumNeighbors"})," to ",(0,n.jsx)(r.code,{children:"i * MaxNumNeighbors + MaxNumNeighbors - 1"})," contain neighbors for entity ",(0,n.jsx)(r.code,{children:"i"})," from ",(0,n.jsx)(r.code,{children:"neighborQueryParams.BaseBehaviorParams"}),". Each ",(0,n.jsx)(r.code,{children:"NeighborMatch"})," element contains the index of neighbor ",(0,n.jsx)(r.code,{children:"j"})," inside ",(0,n.jsx)(r.code,{children:"neighborQueryParams.OtherBehaviorParams"}),". Elements in the array where ",(0,n.jsx)(r.code,{children:"OtherIndex"})," is ",(0,n.jsx)(r.code,{children:"-1"})," signify none neighbor."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",metastring:'title="INeighborQueryJobWrapper.cs"',children:"public struct NeighborMatch\r\n{\r\n    public int OtherIndex; // index of the neighbor inside OtherBehaviorParams\r\n    public float DistanceToOrigin; // distance between origins\r\n    public float DistanceToSurface; // distance between origins minus the radii of the two entities\r\n}\n"})})]})}function b(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,r,i)=>{i.d(r,{R:()=>s,x:()=>a});var n=i(6540);const o={},t=n.createContext(o);function s(e){const r=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);