"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8821],{4810:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});var n=t(4848),a=t(8453);t(6025);const i={sidebar_position:2},o="IRaycastBehaviorJobWrapper",s={id:"documentation-core/behaviors/ray-behaviors/ray-behaviors",title:"IRaycastBehaviorJobWrapper",description:"Ray behaviors are implementations of IRaycastBehaviorJobWrapper. The BaseSteeringSystem schedules them after their corresponding ray query is done, passing in its results. There are three interfaces relevant in creating a ray behavior. The most important one is a custom job IRaycastBehaviorJob which significantly simplifies creating the behaviors.",source:"@site/docs/4_documentation-core/6_behaviors/2_ray-behaviors/1_ray-behaviors.mdx",sourceDirName:"4_documentation-core/6_behaviors/2_ray-behaviors",slug:"/documentation-core/behaviors/ray-behaviors/ray-behaviors",permalink:"/docs/documentation-core/behaviors/ray-behaviors/ray-behaviors",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/documentation-core/behaviors/ray-behaviors/overview"},next:{title:"IAccumulator",permalink:"/docs/documentation-core/behaviors/accumulators"}},c={},h=[{value:"Implementing IRaycastBehaviorJobWrapper",id:"implementing-iraycastbehaviorjobwrapper",level:2},{value:"Attributes",id:"attributes",level:3},{value:"Implementing IRaycastBehaviorJob&lt;C, A1, A2, R&gt;",id:"implementing-iraycastbehaviorjobc-a1-a2-r",level:2},{value:"Generic Parameters",id:"generic-parameters",level:3}];function l(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"iraycastbehaviorjobwrapper",children:"IRaycastBehaviorJobWrapper"})}),"\n",(0,n.jsxs)(r.p,{children:["Ray behaviors are implementations of ",(0,n.jsx)(r.code,{children:"IRaycastBehaviorJobWrapper"}),". The ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/base-system/BaseSteeringSystem",children:(0,n.jsx)(r.code,{children:"BaseSteeringSystem"})})," schedules them after their corresponding ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/queries/ray_queries/overview",children:"ray query"})," is done, passing in its results. There are three interfaces relevant in creating a ray behavior. The most important one is a ",(0,n.jsx)(r.a,{href:"https://docs.unity3d.com/Packages/com.unity.jobs@0.0/manual/custom_job_types.html",children:"custom job"})," ",(0,n.jsx)(r.code,{children:"IRaycastBehaviorJob<C, A1, A2, R>"})," which significantly simplifies creating the behaviors."]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/docs/documentation-core/behaviors/ray-behaviors/ray-behaviors#implementing-iraycastbehaviorjobwrapper",children:(0,n.jsx)(r.code,{children:"IRayBehaviorJobWrapper"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"Schedule"})," should schedule a job which writes ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/VelocityResult",children:(0,n.jsx)(r.code,{children:"VelocityResult"})}),"s to ",(0,n.jsx)(r.code,{children:"results"}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/docs/documentation-core/behaviors/ray-behaviors/ray-behaviors#implementing-iraycastbehaviorjobc-a1-a2-r",children:(0,n.jsx)(r.code,{children:"IRaycastBehaviorJob<C, A1, A2, R>"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"Finalize"})," should return a single ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/VelocityResult",children:(0,n.jsx)(r.code,{children:"VelocityResult"})}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"OnHit"})," runs once per each entity ray hit pair."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"OnMiss"})," once per each entity ray miss pair."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/docs/documentation-core/components/IRayBaseBehavior",children:(0,n.jsx)(r.code,{children:"IRayBaseBehavior"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["Entities used by ",(0,n.jsx)(r.code,{children:"IRaycastBehaviorJob<C, A1, A2, R>"})," must have a component implementing this interface."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"implementing-iraycastbehaviorjobwrapper",children:"Implementing IRaycastBehaviorJobWrapper"}),"\n",(0,n.jsxs)(r.p,{children:["Below is the implementation of the ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/ray-behaviors/debug-rays",children:(0,n.jsx)(r.code,{children:"DebugRaysJobWrapper"})}),". It can be easily used as a template to create your own behavior. The ",(0,n.jsx)(r.code,{children:"Schedule"})," method receives information about the entities as well as the result of its group's ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/queries/ray_queries/overview",children:"ray query"})," inside ",(0,n.jsx)(r.code,{children:"RaycastBehaviorParams"}),". It should create an object of the type specified in ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes#outdataattribute",children:(0,n.jsx)(r.code,{children:"[OutData]"})})," and assign it to ",(0,n.jsx)(r.code,{children:"out results"}),". The behavior should write one ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/VelocityResult",children:(0,n.jsx)(r.code,{children:"VelocityResult"})})," per entity into ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/VelocityResult",children:(0,n.jsx)(r.code,{children:"VelocityResults"})}),". Here the ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/ray-behaviors/debug-rays",children:(0,n.jsx)(r.code,{children:"DebugRaysJob"})})," is resposible for that."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",metastring:'title="DebugRayJobWrapper.cs"',children:"[JobWrapper(typeof(DebugRayComponent))]\r\n[OutData(typeof(VelocityResults))] \r\npublic class DebugRayJobWrapper : IRaycastBehaviorJobWrapper\r\n{\r\n    public JobHandle Schedule(\r\n        SystemBase systemBase,\r\n        in RaycastBehaviorParams rayBehaviorParams,\r\n        out IDelayedDisposable results,\r\n        in JobHandle dependency)\r\n    {\r\n        results = new VelocityResults(rayBehaviorParams.MainBaseParams.EntityCount);\r\n        var outDependency = new DebugRayJob().Schedule<\r\n            DebugRayJob, \r\n            DebugRayComponent, \r\n            NoneAccumulator, \r\n            NoneAccumulator, \r\n            VelocityResult>(systemBase, rayBehaviorParams, (VelocityResults)results, 1, dependency);\r\n        return outDependency;\r\n    }\r\n}\n"})}),"\n",(0,n.jsx)(r.h3,{id:"attributes",children:"Attributes"}),"\n",(0,n.jsxs)(r.p,{children:["This job wrapper uses two ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes",children:"attributes"}),". First declares what type of object the behavior returns. Second declares which components are expected on the entity. The types from the ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes",children:"attributes"})," are used in the ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/editor",children:"editor"})," of the ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/base-system/SteeringSystemAsset",children:(0,n.jsx)(r.code,{children:"SteeringSystemAsset"})}),"."]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes#outdataattribute",children:(0,n.jsx)(r.code,{children:"[OutData]"})})," - Declares what type of results the behavior creates, above ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/VelocityResult",children:(0,n.jsx)(r.code,{children:"VelocityResults"})}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes#jobwrapperattribute",children:(0,n.jsx)(r.code,{children:"[JobWrapper]"})})," - Declares which components should be present on the entity, above ",(0,n.jsx)(r.a,{href:"/docs/documentation-defaults/behaviors/ray-behaviors/debug-rays#debugrayscomponent",children:(0,n.jsx)(r.code,{children:"DebugRayComponent"})}),"."]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["The correct way to match the type arguments with generic parameters to ",(0,n.jsx)(r.code,{children:"IRaycastBehaviorJob<C, A1, A2, R>"})," is the following:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.code,{children:"[JobWrapper(typeof(C))]"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.code,{children:"[OutData(typeof(R))]"})}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"implementing-iraycastbehaviorjobc-a1-a2-r",children:"Implementing IRaycastBehaviorJob<C, A1, A2, R>"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"IRaycastBehaviorJob<C, A1, A2, R>"})," simplifies creation of new ray behaviors. For each entity, ",(0,n.jsx)(r.code,{children:"OnHit"})," is called for each ray of the query which hit and ",(0,n.jsx)(r.code,{children:"OnMiss"})," for each ray missed. Information about the entity and the ray are passed in. Both functions also receive an ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/behaviors/accumulators",children:"accumulator"}),". After influence of all rays is accumulated into the accumulators, they are passed with information about the entity into the ",(0,n.jsx)(r.code,{children:"Finalize"})," method. That then returns a single result of type ",(0,n.jsx)(r.code,{children:"R"})," per entity. Internally the result is then written into the ",(0,n.jsx)(r.code,{children:"results"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"generic-parameters",children:"Generic Parameters"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"C"})," - Type of component expected on the main entities - should match the argument of ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes#jobwrapperattribute",children:(0,n.jsx)(r.code,{children:"[JobWrapper]"})}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"A1"})," - Type of accumulator passed into the ",(0,n.jsx)(r.code,{children:"OnHit"})," method, implements ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/behaviors/accumulators",children:"IAccumulator"}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"A2"})," - Type of accumulator passed into the ",(0,n.jsx)(r.code,{children:"OnMiss"})," method, implements ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/behaviors/accumulators",children:"IAccumulator"}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"R"})," - Type of result returned from the behavior - should match the argument of ",(0,n.jsx)(r.a,{href:"/docs/documentation-core/attributes#outdataattribute",children:(0,n.jsx)(r.code,{children:"[OutData]"})}),"."]}),"\n"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",metastring:'title="DebugRayJobWrapper.cs"',children:"[BurstCompile]\r\nstruct DebugRayJob : IRaycastBehaviorJob<DebugRayComponent, NoneAccumulator, NoneAccumulator, VelocityResult>\r\n{\r\n    public void OnHit(\r\n        in EntityInformation<DebugRayComponent> entity,\r\n        in RayData rayData,\r\n        in RaycastHit hit,\r\n        ref NoneAccumulator hitA)\r\n    // highlight-start\r\n    {\r\n        // Accumulate something from rays that hit the environment into accumulator\r\n        DebugDraw.DrawArrow(entity.Position, raycastHit.Position, Color.red);\r\n    }\r\n    // highlight-end\r\n\r\n    public void OnMiss(\r\n        in EntityInformation<DebugRayComponent> entity, \r\n        in RayData rayData, \r\n        ref NoneAccumulator missA)\r\n    // highlight-start\r\n    {\r\n        // Accumulate something from rays that missed the environment into accumulator\r\n        DebugDraw.DrawArrow(\r\n            entity.Position,\r\n            entity.Position + rayData.Direction * rayData.MaxDistance, \r\n            Color.green);\r\n    }\r\n    // highlight-end\r\n\r\n    public VelocityResult Finalize(\r\n        in EntityInformation<DebugRayComponent> entity,\r\n        in NoneAccumulator hitA,\r\n        in NoneAccumulator missA)\r\n    // highlight-start\r\n    {\r\n        // Based on the accumulators, return a VelocityResult which tells which way to go\r\n        return default;\r\n    }\r\n    // highlight-end\r\n}\n"})}),"\n",(0,n.jsx)(r.admonition,{type:"tip",children:(0,n.jsxs)(r.p,{children:["You can just copy and paste this, then change all occurences of ",(0,n.jsx)(r.code,{children:"DebugRay"})," to ",(0,n.jsx)(r.code,{children:"MyBehaviorName"})," to create a new behavior quickly. The only three things to implement are the ",(0,n.jsx)(r.code,{children:"OnHit"}),", ",(0,n.jsx)(r.code,{children:"OnMiss"})," and ",(0,n.jsx)(r.code,{children:"Finalize"})," methods. See other ",(0,n.jsx)(r.a,{href:"/docs/category/ray-behaviors-1",children:"default behaviors"})," to understand more complex examples."]})})]})}function d(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>o,x:()=>s});var n=t(6540);const a={},i=n.createContext(a);function o(e){const r=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);