"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9075],{5430:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=s(4848),n=s(8453);s(6025);const r={sidebar_position:2},a="Spacial Hash KNN",o={id:"documentation-defaults/queries/neighbor-queries/spacial-hash-knn",title:"Spacial Hash KNN",description:"For each entity finds maximum of MaxNumNeighbors within radius MaxNeighborDistance. It's also possible to limit the field of view with MaxFOV. Functionally it is exactly the same as KDTreeKNNJobWrapper. The only difference is in the data structure used. Usually, spacial hashing provides better performance, but proper profiling is always necessary.",source:"@site/docs/5_documentation-defaults/2_queries/neighbor-queries/2_spacial-hash-knn.mdx",sourceDirName:"5_documentation-defaults/2_queries/neighbor-queries",slug:"/documentation-defaults/queries/neighbor-queries/spacial-hash-knn",permalink:"/docs/documentation-defaults/queries/neighbor-queries/spacial-hash-knn",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"KD Tree KNN",permalink:"/docs/documentation-defaults/queries/neighbor-queries/kd-tree-knn"},next:{title:"Ray Queries",permalink:"/docs/category/ray-queries-1"}},c={},d=[];function u(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"spacial-hash-knn",children:"Spacial Hash KNN"})}),"\n",(0,t.jsxs)(i.p,{children:["For each entity finds maximum of ",(0,t.jsx)(i.code,{children:"MaxNumNeighbors"})," within radius ",(0,t.jsx)(i.code,{children:"MaxNeighborDistance"}),". It's also possible to limit the field of view with ",(0,t.jsx)(i.code,{children:"MaxFOV"}),". Functionally it is exactly the same as ",(0,t.jsx)(i.a,{href:"/docs/documentation-defaults/queries/neighbor-queries/kd-tree-knn",children:(0,t.jsx)(i.code,{children:"KDTreeKNNJobWrapper"})}),". The only difference is in the data structure used. Usually, spacial hashing provides better performance, but proper profiling is always necessary."]}),"\n",(0,t.jsx)(i.admonition,{type:"tip",children:(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.a,{href:"/docs/documentation-core/queries/neighbor_queries/overview",children:"Neighbor queries"})," can easily cost most of the resources needed to run a steering system. Try to limit the ",(0,t.jsx)(i.code,{children:"MaxNumNeighbors"})," and ",(0,t.jsx)(i.code,{children:"MaxNeighborDistance"})," to minimum."]})})]})}function l(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>a,x:()=>o});var t=s(6540);const n={},r=t.createContext(n);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);