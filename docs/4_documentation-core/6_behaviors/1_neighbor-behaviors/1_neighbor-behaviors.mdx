---
sidebar_position: 1
---

# INeighborBehaviorJobWrapper

Neighbor behaviors are implementations of `INeighborBehaviorJobWrapper`. The `BaseSystem` schedules them after their corresponding neighbor query is done, passing in its results.

### Implementing a Neighbor Behavior

Below is the implementation of the `DebugJobWrapper`. It can be easily used as a template to create your own behavior. The `Schedule` method receives information about the entities as well as it's neighbors inside `NeighborBehaviorParams`. It should allocate an object of the type specified in `OutDataAttribute` and assign it to `out results`. The behavior should write one `VelocityResult` per entity into `VelocityResults`. Here the `DebugJob` is resposible for that.

#### Attributes

This job wrapper uses two attributes. First declares what type of object the behavior returns. Second declares which components are expected on the entity and it's neighbor. The types from the attributes are used in the editor of the `SteeringSystemAsset`. 

- `OutDataAttribute` - *declares what type of results the behavior creates, above `VelocityResults`*
- `JobWrapperAttribute` - *declares which components should be present on the entity and neighbor respectively, above `DebugableComponent` and `SteeringEntityTagComponent`*

```csharp title="DebugableJobWrapper.cs"
[JobWrapper(typeof(DebugableComponent), typeof(SteeringEntityTagComponent))]
[OutData(typeof(VelocityResults))]
class DebugableJobWrapper : INeighborBehaviorJobRunner
{
    public JobHandle Schedule(
        SystemBase systemBase,
        in NeighborBehaviorParams neighborBehaviorParams,
        out IDelayedDisposable results,
        in JobHandle dependency)
    {	
        results = new VelocityResults(neighborBehaviorParams.BaseBehaviorParams.EntityCount);
        var outDependency = new DebugableJob().Schedule<
            DebugJob, 
            DebugableComponent, 
            SteeringEntityTagComponent, 
            NoneAccumulator, 
            VelocityResult>(systemBase, neighborBehaviorParams, (VelocityResults)results, 1, dependency);
        return outDependency;
    }
}
```


### INeighborBehaviorJob\<C1, C2, A, R\>

`INeighborBehaviorJob<C1, C2, A, R>` simplifies creation of new neighbor behaviors. For each entity, the `Execute` is called up to `MaxNumNeighbors` times, once for each neighbor. Information about the entity and it's neighbor are passed in the `behaviorData` parameter. It has one component from both of the entities, depending on the generics. The `Execute` method also receives reference to an accumulator. After influence of all neighbors is accumulated into the accumulator, it is passed with information about the entity into the `Finalize` method. That then returns a single the `VelocityResult` per entity.

#### Generic Parameters

- `C1` - *type of component expected on the main entities*
- `C2` - *type of component expected on the neighbors*
- `A` - *type of accumulator passed into the `Exectute` method*
- `R` - *type of result returned from the behavior*

```csharp title="DebugableJobWrapper.cs"
[BurstCompile]
struct DebugableJob : INeighborBehaviorJob<
    DebugableComponent, 
    SteeringEntityTagComponent, 
    NoneAccumulator, 
    VelocityResult>
{
    public void Execute(
        in NeighborBehaviorData<DebugableComponent, SteeringEntityTagComponent> behaviorData,
        ref NoneAccumulator accumulator)
    // highlight-start
    {
        // Accumulate something about the neighbors into the accumulator
        Debug.DrawLine(behaviorData.Entity.Position, behaviorData.OtherEntity.Position);
    }
    // highlight-end

    // highlight-start
    public VelocityResult Finalize(
        in EntityInformation<DebugableComponent> entity,
        in NoneAccumulator accumulator)
    // highlight-start
    {
        // Based on the accumulator, return a VelocityResult which tells which way to go
        return default;
    }
    // highlight-end
}
```

:::tip
You can just copy and paste this, then change all occurences of `Debugable` to `MyBehaviorName` to create a new behavior quickly. See other behaviors in [link] to understand more complex examples. The only two things to implement are the `Execute` and `Finalize` methods.
:::