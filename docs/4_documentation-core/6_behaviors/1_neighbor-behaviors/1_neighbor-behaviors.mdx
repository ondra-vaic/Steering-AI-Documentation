---
sidebar_position: 1
---

# INeighborBehaviorJobWrapper

Neighbor behaviors are implementations of `INeighborBehaviorJobWrapper`. The `BaseSystem` schedules them after their corresponding neighbor query is done, passing in its results.

## Implementing INeighborBehaviorJobWrapper

Below is the implementation of the `DebugNeighborsJobWrapper`. It can be easily used as a template to create your own behavior. The `Schedule` method receives information about the entities as well as it's neighbors inside `NeighborBehaviorParams`. It should allocate an object of the type specified in `OutDataAttribute` and assign it to `out results`. The behavior should write one `VelocityResult` per entity into `VelocityResults`. Here the `DebugaNeighborsJob` is resposible for that.

```csharp title="DebugNeighborsJobWrapper.cs"
[JobWrapper(typeof(DebugNeighborsComponent), typeof(SteeringEntityTagComponent))]
[OutData(typeof(VelocityResults))]
class DebugaNeighborsJobWrapper : INeighborBehaviorJobRunner
{
    public JobHandle Schedule(
        SystemBase systemBase,
        in NeighborBehaviorParams neighborBehaviorParams,
        out IDelayedDisposable results,
        in JobHandle dependency)
    {	
        results = new VelocityResults(neighborBehaviorParams.BaseBehaviorParams.EntityCount);
        var outDependency = new DebugNeighborsJob().Schedule<
            DebugJob, 
            DebugaNeighborsComponent, 
            SteeringEntityTagComponent, 
            NoneAccumulator, 
            VelocityResult>(systemBase, neighborBehaviorParams, (VelocityResults)results, 1, dependency);
        return outDependency;
    }
}
```

### Attributes

This job wrapper uses two attributes. First declares what type of object the behavior returns. Second declares which components are expected on the entity and it's neighbor. The types from the attributes are used in the editor of the `SteeringSystemAsset`. 

- `OutDataAttribute` - *declares what type of results the behavior creates, above `VelocityResults`*
- `JobWrapperAttribute` - *declares which components should be present on the entity and neighbor respectively, above `DebugaNeighborsComponent` and `SteeringEntityTagComponent`*

## Implementing INeighborBehaviorJob\<C1, C2, A, R\>

`INeighborBehaviorJob<C1, C2, A, R>` simplifies creation of new neighbor behaviors. For each entity, the `Execute` is called up to `MaxNumNeighbors` times, once for each neighbor. Information about the entity and it's neighbor are passed in the `behaviorData` parameter. It has one component from both of the entities, depending on the generics. The `Execute` method also receives reference to an accumulator. After influence of all neighbors is accumulated into the accumulator, it is passed with information about the entity into the `Finalize` method. That then returns a single result of type `R` per entity. Internally the result is then written into the `results`. 

### Generic Parameters

- `C1` - *type of component expected on the main entities - should match the first argument of `JobWrapper`*
- `C2` - *type of component expected on the neighbors - should match the second argument of `JobWrapper`*
- `A` - *type of accumulator passed into the `Exectute` method*
- `R` - *type of result returned from the behavior - should match the argument of `OutData`*

```csharp title="DebugaNeighborsJobWrapper.cs"
[BurstCompile]
struct DebugNeighborsJob : INeighborBehaviorJob<
    DebugaNeighborsComponent, 
    SteeringEntityTagComponent, 
    NoneAccumulator, 
    VelocityResult>
{
    public void Execute(
        in NeighborBehaviorData<DebugaNeighborsComponent, SteeringEntityTagComponent> behaviorData,
        ref NoneAccumulator accumulator)
    // highlight-start
    {
        // Accumulate something about the neighbors into the accumulator
        Debug.DrawLine(behaviorData.Entity.Position, behaviorData.OtherEntity.Position);
    }
    // highlight-end

    // highlight-start
    public VelocityResult Finalize(
        in EntityInformation<DebugaNeighborsComponent> entity,
        in NoneAccumulator accumulator)
    // highlight-start
    {
        // Based on the accumulator, return a VelocityResult which tells which way to go
        return default;
    }
    // highlight-end
}
```

:::tip
You can just copy and paste this, then change all occurences of `Debugable` to `MyBehaviorName` to create a new behavior quickly. See other behaviors in [link] to understand more complex examples. The only two things to implement are the `Execute` and `Finalize` methods.
:::